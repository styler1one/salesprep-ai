/**
 * Export utilities for downloading content as different file formats
 * Supports: Markdown (.md), PDF (.pdf), Word (.docx)
 */

import { saveAs } from 'file-saver'
import { 
  Document, 
  Packer, 
  Paragraph, 
  TextRun, 
  HeadingLevel,
  AlignmentType,
  BorderStyle
} from 'docx'

/**
 * Sanitize filename - remove special characters and spaces
 */
function sanitizeFilename(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '')
}

/**
 * Export content as Markdown file
 */
export function exportAsMarkdown(content: string, companyName: string): void {
  const filename = `${sanitizeFilename(companyName)}_brief.md`
  const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' })
  saveAs(blob, filename)
}

/**
 * Export content as PDF file
 * Uses html2pdf.js for conversion
 */
export async function exportAsPdf(
  content: string, 
  companyName: string,
  title: string
): Promise<void> {
  // Dynamic import to avoid SSR issues
  const html2pdf = (await import('html2pdf.js')).default
  
  // Convert markdown to styled HTML
  const htmlContent = markdownToHtml(content)
  
  // Create a styled container
  const container = document.createElement('div')
  container.innerHTML = `
    <div style="font-family: 'Segoe UI', Arial, sans-serif; padding: 40px; max-width: 800px; margin: 0 auto;">
      <div style="border-bottom: 3px solid #3b82f6; padding-bottom: 20px; margin-bottom: 30px;">
        <h1 style="color: #1e293b; font-size: 28px; margin: 0 0 8px 0;">${title}</h1>
        <p style="color: #64748b; font-size: 14px; margin: 0;">Research Brief • ${new Date().toLocaleDateString()}</p>
      </div>
      <div style="color: #334155; line-height: 1.7; font-size: 14px;">
        ${htmlContent}
      </div>
      <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e2e8f0; color: #94a3b8; font-size: 12px; text-align: center;">
        Generated by DealMotion • ${new Date().toLocaleDateString()}
      </div>
    </div>
  `
  
  const filename = `${sanitizeFilename(companyName)}_brief.pdf`
  
  const options = {
    margin: 10,
    filename: filename,
    image: { type: 'jpeg', quality: 0.98 },
    html2canvas: { scale: 2, useCORS: true },
    jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' as const }
  }
  
  await html2pdf().set(options).from(container).save()
}

/**
 * Export content as Word document (.docx)
 * Uses docx library for generation
 */
export async function exportAsDocx(
  content: string, 
  companyName: string,
  title: string
): Promise<void> {
  const paragraphs = parseMarkdownToParagraphs(content, title)
  
  const doc = new Document({
    styles: {
      paragraphStyles: [
        {
          id: 'Normal',
          name: 'Normal',
          basedOn: 'Normal',
          next: 'Normal',
          run: {
            font: 'Calibri',
            size: 24, // 12pt
          },
          paragraph: {
            spacing: { after: 200 },
          },
        },
      ],
    },
    sections: [
      {
        properties: {},
        children: paragraphs,
      },
    ],
  })
  
  const buffer = await Packer.toBlob(doc)
  const filename = `${sanitizeFilename(companyName)}_brief.docx`
  saveAs(buffer, filename)
}

/**
 * Convert markdown content to HTML for PDF generation
 */
function markdownToHtml(markdown: string): string {
  return markdown
    // Headers
    .replace(/^### (.*$)/gm, '<h3 style="color: #1e293b; font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">$1</h3>')
    .replace(/^## (.*$)/gm, '<h2 style="color: #1e293b; font-size: 20px; font-weight: 600; margin: 28px 0 16px 0; padding-bottom: 8px; border-bottom: 1px solid #e2e8f0;">$1</h2>')
    .replace(/^# (.*$)/gm, '<h1 style="color: #1e293b; font-size: 24px; font-weight: 700; margin: 32px 0 16px 0;">$1</h1>')
    // Bold and italic
    .replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>')
    .replace(/\*\*(.*?)\*\*/g, '<strong style="font-weight: 600;">$1</strong>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    // Lists
    .replace(/^\s*[-*]\s+(.*$)/gm, '<li style="margin: 4px 0; margin-left: 20px;">$1</li>')
    .replace(/(<li.*<\/li>\n?)+/g, '<ul style="margin: 12px 0; padding-left: 0;">$&</ul>')
    // Numbered lists
    .replace(/^\d+\.\s+(.*$)/gm, '<li style="margin: 4px 0; margin-left: 20px;">$1</li>')
    // Paragraphs (lines not starting with tags)
    .replace(/^(?!<[hul])(.*$)/gm, (match) => {
      if (match.trim() === '') return '<br/>'
      if (match.startsWith('<')) return match
      return `<p style="margin: 12px 0;">${match}</p>`
    })
    // Clean up extra breaks
    .replace(/<br\/>\s*<br\/>/g, '<br/>')
    .replace(/<p style="margin: 12px 0;"><\/p>/g, '')
}

/**
 * Parse markdown content into docx paragraphs
 */
function parseMarkdownToParagraphs(content: string, title: string): Paragraph[] {
  const paragraphs: Paragraph[] = []
  
  // Title
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: title,
          bold: true,
          size: 56, // 28pt
          color: '1e293b',
        }),
      ],
      spacing: { after: 100 },
    })
  )
  
  // Subtitle
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Research Brief • ${new Date().toLocaleDateString()}`,
          size: 24, // 12pt
          color: '64748b',
        }),
      ],
      spacing: { after: 400 },
      border: {
        bottom: {
          color: '3b82f6',
          space: 10,
          style: BorderStyle.SINGLE,
          size: 24,
        },
      },
    })
  )
  
  // Parse content lines
  const lines = content.split('\n')
  
  for (const line of lines) {
    const trimmedLine = line.trim()
    
    if (!trimmedLine) {
      paragraphs.push(new Paragraph({ children: [] }))
      continue
    }
    
    // H1
    if (trimmedLine.startsWith('# ')) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.replace(/^# /, ''),
              bold: true,
              size: 48, // 24pt
            }),
          ],
          heading: HeadingLevel.HEADING_1,
          spacing: { before: 400, after: 200 },
        })
      )
      continue
    }
    
    // H2
    if (trimmedLine.startsWith('## ')) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.replace(/^## /, ''),
              bold: true,
              size: 36, // 18pt
            }),
          ],
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 300, after: 150 },
          border: {
            bottom: {
              color: 'e2e8f0',
              space: 5,
              style: BorderStyle.SINGLE,
              size: 8,
            },
          },
        })
      )
      continue
    }
    
    // H3
    if (trimmedLine.startsWith('### ')) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: trimmedLine.replace(/^### /, ''),
              bold: true,
              size: 28, // 14pt
            }),
          ],
          heading: HeadingLevel.HEADING_3,
          spacing: { before: 200, after: 100 },
        })
      )
      continue
    }
    
    // Bullet points
    if (trimmedLine.startsWith('- ') || trimmedLine.startsWith('* ')) {
      const text = trimmedLine.replace(/^[-*] /, '')
      paragraphs.push(
        new Paragraph({
          children: parseTextWithFormatting(text),
          bullet: { level: 0 },
          spacing: { after: 80 },
        })
      )
      continue
    }
    
    // Numbered lists
    if (/^\d+\. /.test(trimmedLine)) {
      const text = trimmedLine.replace(/^\d+\. /, '')
      paragraphs.push(
        new Paragraph({
          children: parseTextWithFormatting(text),
          numbering: { reference: 'default-numbering', level: 0 },
          spacing: { after: 80 },
        })
      )
      continue
    }
    
    // Regular paragraph
    paragraphs.push(
      new Paragraph({
        children: parseTextWithFormatting(trimmedLine),
        spacing: { after: 150 },
      })
    )
  }
  
  // Footer
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Generated by DealMotion • ${new Date().toLocaleDateString()}`,
          size: 20, // 10pt
          color: '94a3b8',
          italics: true,
        }),
      ],
      alignment: AlignmentType.CENTER,
      spacing: { before: 600 },
      border: {
        top: {
          color: 'e2e8f0',
          space: 10,
          style: BorderStyle.SINGLE,
          size: 8,
        },
      },
    })
  )
  
  return paragraphs
}

/**
 * Parse text with bold/italic formatting into TextRuns
 */
function parseTextWithFormatting(text: string): TextRun[] {
  const runs: TextRun[] = []
  
  // Simple regex-based parsing for bold and italic
  const parts = text.split(/(\*\*.*?\*\*|\*.*?\*)/g)
  
  for (const part of parts) {
    if (!part) continue
    
    if (part.startsWith('**') && part.endsWith('**')) {
      runs.push(
        new TextRun({
          text: part.slice(2, -2),
          bold: true,
          size: 24,
        })
      )
    } else if (part.startsWith('*') && part.endsWith('*')) {
      runs.push(
        new TextRun({
          text: part.slice(1, -1),
          italics: true,
          size: 24,
        })
      )
    } else {
      runs.push(
        new TextRun({
          text: part,
          size: 24,
        })
      )
    }
  }
  
  return runs.length > 0 ? runs : [new TextRun({ text, size: 24 })]
}

